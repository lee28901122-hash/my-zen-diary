<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>境·界 | 灵动交互版</title>
    <style>
        :root { --bg: #0d0f14; --white: #fdfaf2; }
        
        /* 彻底消除所有选中文本的可能性 */
        * { 
            -webkit-tap-highlight-color: transparent; 
            -webkit-touch-callout: none; 
            -webkit-user-select: none; 
            -khtml-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none; 
        }

        body, html {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; background-color: var(--bg);
            font-family: "STKaiti", "KaiTi", serif;
            touch-action: none; 
        }

        #canvas { position: absolute; top: 0; left: 0; z-index: 1; }

        .overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 10; display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            /* 让文字层完全不响应触摸，所有触摸直接穿透到Canvas */
            pointer-events: none; 
        }

        #prompt-text {
            color: var(--white); font-size: 22px; letter-spacing: 6px;
            opacity: 0.3; transition: opacity 2s ease; font-weight: 300;
        }

        #mood-feedback {
            position: fixed; bottom: 80px; color: var(--white);
            font-size: 13px; opacity: 0.15; letter-spacing: 2px;
        }
    </style>
</head>
<body>

    <canvas id="canvas"></canvas>
    <div class="overlay">
        <p id="prompt-text">凝神 · 触碰</p >
        <p id="mood-feedback">万物归心...</p >
    </div>

<script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const prompt = document.getElementById('prompt-text');

    let width, height, particles = [];
    let mouse = { x: -1000, y: -1000, active: false };

    const sizes = [1.5, 3, 4.5, 6, 8];

    class Particle {
        constructor() {
            this.init();
        }
        init() {
            // 设置初始位置（家）
            this.homeX = this.x = Math.random() * width;
            this.homeY = this.y = Math.random() * height;
            
            const level = Math.floor(Math.random() * 5);
            this.baseSize = sizes[level];
            
            this.vx = 0;
            this.vy = 0;
            
            this.friction = 0.92; // 阻力，越高滑动越久
            this.springFactor = 0.005 + Math.random() * 0.01; // 回家拉力强度
            
            this.breatheSpeed = 0.01 + Math.random() * 0.015;
            this.breatheOffset = Math.random() * Math.PI * 2;
            this.alpha = 0;
            this.maxSpeed = 1.25 + (level * 0.25); // 限制最大速度，防止过快
        }

        update() {
            if (mouse.active) {
                // 交互中：受指尖引力
                const dx = mouse.x - this.x;
                const dy = mouse.y - this.y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                
                if (dist < 350) {
                    const force = (350 - dist) * 0.0003; 
                    this.vx += dx * force;
                    this.vy += dy * force;
                }
            } else {
                // 回家逻辑：弹性拉力
                const dx = this.homeX - this.x;
                const dy = this.homeY - this.y;
                this.vx += dx * this.springFactor;
                this.vy += dy * this.springFactor;
            }

            // 速度上限控制
            const speed = Math.sqrt(this.vx * this.vx + this.vy * this.vy);
            if (speed > this.maxSpeed) {
                this.vx = (this.vx / speed) * this.maxSpeed;
                this.vy = (this.vy / speed) * this.maxSpeed;
            }

            this.vx *= this.friction;
            this.vy *= this.friction;
            this.x += this.vx;
            this.y += this.vy;

            this.breatheOffset += this.breatheSpeed;
            this.alpha = 0.2 + Math.abs(Math.sin(this.breatheOffset)) * 0.6;
        }

        draw() {
            ctx.globalAlpha = this.alpha;
            ctx.fillStyle = "#fdfaf2";
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.baseSize, 0, Math.PI * 2);
            ctx.fill();
            
            if (this.baseSize > 5) {
                ctx.shadowBlur = 10;
                ctx.shadowColor = "rgba(253, 250, 242, 0.3)";
            }
        }
    }

    function setup() {
        const dpr = window.devicePixelRatio || 1;
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width * dpr;
        canvas.height = height * dpr;
        ctx.scale(dpr, dpr);

        particles = [];
        for (let i = 0; i < 80; i++) particles.push(new Particle());
    }

    function loop() {
        // 背景微光，不再使用残影，确保画质清晰
        ctx.fillStyle = "#0d0f14";
        ctx.fillRect(0, 0, width, height);

        particles.forEach(p => {
            p.update();
            p.draw();
        });
        requestAnimationFrame(loop);
    }

    // 针对手机端极致优化的事件
    const handleTouch = (e) => {
        const t = e.touches[0];
        mouse.x = t.clientX;
        mouse.y = t.clientY;
    };

    window.addEventListener('touchstart', e => {
        mouse.active = true;
        handleTouch(e);
        prompt.style.opacity = "0.05";
        e.preventDefault();
    }, { passive: false });

    window.addEventListener('touchmove', e => {
        handleTouch(e);
        e.preventDefault();
    }, { passive: false });

    window.addEventListener('touchend', () => {
        mouse.active = false;
        setTimeout(() => { prompt.style.opacity = "0.3"; }, 1500);
    });

    window.addEventListener('resize', setup);
    setup();
    loop();
</script>
</body>
</html>
